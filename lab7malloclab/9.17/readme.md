## 开发9.9.12节中的分配器的下一个版本， 执行下一次适配搜索，而不是首次适配搜索

我去下载书上的版本的时候，我发现老师们已经实现了Next fit search，所以我就没有实现了，但是得理解思路。

下面是这个实现的思路：
first fit search 和Next fit search **是非常类似的，后者从上一次查询结束的位置开始搜索，前者从头开始搜**
所以我们只需要记录一个rover，每次从rover开始检索分配即可。
需要注意的是：**合并空闲块后，如果rover在里面，得让rover = bp**

内存利用率：**first < next < best** 
运行速度：**best < first < next**

源实现是一个：基于隐式空闲链表。 使用立即边界合并方式，从头至尾讲述了一个简单分配器的实现， 最大的块为 2^32 = 4GB

memlib.c是一个内存系统模型
mem_init 将对于堆来说可用的虚拟内存模型化为一个**大的、双字对齐**的字节数组
mem_brk 会拒绝堆收缩

最后用csapp 的测试测了一下，可以有了很大的性能提升。主要是在速度上
Results for mm malloc:
trace  valid  util     ops      secs  Kops
 0       yes   91%    5694  0.003001  1897
 1       yes   92%    5848  0.001165  5018
 2       yes   95%    6648  0.003336  1993
 3       yes   97%    5380  0.004271  1260
 4       yes   66%   14400  0.000420 34310
 5       yes   90%    4800  0.007798   616
 6       yes   89%    4800  0.006489   740
 7       yes   55%   12000  0.017846   672
 8       yes   51%   24000  0.009879  2429
 9       yes   27%   14401  0.114289   126
10       yes   45%   14401  0.004324  3330
Total          73%  112372  0.172818   650

Perf index = 44 (util) + 40 (thru) = 84/100
correct:11
perfidx:84