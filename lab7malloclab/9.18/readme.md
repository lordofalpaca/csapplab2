这个作业的思想是很明了的：

1. 让所有块的head的第二位表示前一块是否已分配
2. 再将所有分配块的foot去掉，当然你也可以不去掉，但是这就没有优化了，我们的目的就是节省这一个foot

首先这样会让最小块的大小变成DSIZE（8个字节），这是之后在place可以优化的地方。

然后我们再来看看需要修改哪些？

1. 整体结构自然不需要改，init不变
2. mm_malloc，因为我们的分配块大小变了，所以得改，按照下图，我们发现除了第一次的进位是4，其他时候的进位都是8，所以我们可以先求4的上整，然后再求出里面8（/2）的个数，记得加1，因为第一次进位是4，最后乘上DSIZE即可。

<img src="pirture/image-20211201201049351.png" alt="image-20211201201049351" style="zoom: 33%;" />

3. extend_heap，需要保护head的ALLOC位
4. place需要保护bp的ALLOC位和**下一个块**的ALLOC位要做适当调整！！
5. mm_free， 需要保护bp的ALLOC位和**下一个块**的ALLOC位要做适当调整！！
6. coalesce 根据case 保护prev的ALLOC位

具体可以参考我的代码 我修改的地方都有 add 9.18，最后这个代码就算完成啦

Results for mm malloc:
trace  valid  util     ops      secs  Kops
 0       yes   90%    5694  0.002052  2775
 1       yes   92%    5848  0.001073  5452
 2       yes   95%    6648  0.002759  2409
 3       yes   96%    5380  0.002827  1903
 4       yes   66%   14400  0.000270 53353
 5       yes   90%    4800  0.004634  1036
 6       yes   89%    4800  0.004461  1076
 7       yes   55%   12000  0.012333   973
 8       yes   51%   24000  0.005909  4061
 9       yes   27%   14401  0.056163   256
10       yes   34%   14401  0.002428  5932
Total          71%  112372  0.094909  1184

Perf index = 43 (util) + 40 (thru) = 83/100

相比9.17我们可以看到我的成绩不增反而降了，内存利用率得分低了1，说实话这和我预想的不一样，那么为什么是这样呢？可能是这8bits的优化真的没有什么意义？还是他的测试标准有问题？我目前不知道答案，不过我想了一下，要让8bits体现出优势，这得是很小并且很多的这样分配才可能有的。所以这个优势确实很微妙，可以说得到比较特别的场景才有用吧。



最后这个作业我一开始调试segmentation fault，之后又一直out of memory调了半天没调好，不过也怪当时条理不清楚，要是一开始就写了这博客，应该能一遍过。思想还是很重要的! 后来参考了他的[博客](https://www.cnblogs.com/liqiuhao/p/8195981.html) （十分感谢他的分享）才发现我是free忘记处理下一块了！！ 另外他写了不少优质的答案，推荐大家去看看~