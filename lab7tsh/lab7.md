这是csapp的lab7，我是按照网上找的2002版的原型代码改动的，不过说实话，还不如不看那份代码，因为，那份代码没有考虑管道，以及真正的**会话的概念**，他是让父进程和子进程在一个前台进程组中抢占终端，说实话这样是很危险的，特别是涉及读入的时候，可能会错读！并且这样实现的管道简直没法看！所以我对任务的实现是分出了多个进程组的，一个命令就是一个进程组，维护一个前台进程组就行了。不过附带的pdf可以看看。

ps：我的运行环境是：ubuntu:20.04，clang version 10.0.0-4ubuntu1 Target: x86_64-pc-linux-gnu，

### 下面是我的设计思路：

1. 父进程也就是tsh就是shell，按照'|' 管道分出**每一个命令，每一个命令是一个进程，父进程依次fork，并执行重定向等处理**
2. 分出的首进程就是，组pid， 然后一个命令中的所有进程都在一个进程组里
3. 父进程要捕捉，子进程的死亡、暂停、因为暂停和死亡的处理不同，所以引入job.processNumber和 fg_num ，依次表示一个job中还存在的进程，**和前台进程组中还在运行的进程数量**。

4. 另外，因为我这里是用信号来捕捉，（事实上我觉得这是最好的方法了）， **所以我只能捕捉到pid**，但是要pgid才能和一个job关联，所以父进程会进行一下group，（一个简单的类似hash的表），映射pid到pgid，方便singhandle处理。

5. 最后就是一些信号处理的细节，一定要保证addjob在deletejob之前！！所以要addjob之后才解开SIGCHLD的阻塞，还有fg_num也是如此。

   

### 下面是各个文件的作用：

1. tsh.c：是整个程序的前端部分，**加上整个程序的逻辑处理**，和管道处理，已经命令的创建和执行，还包括了addjob
2. jobs.c： 实现了jobs控制所需的代码
3. signalHandle.c： 信号处理的代码
4. sio.c ：cs_app 作者提供的信号安全的printf，实际上就是封装了的read
5. tools.c： 我自己实现的一系列字符串处理函数
6. get_num.c： 这是Michael Kerrisk（unix/linux系统编程手册原作者）提供的string_to——numberd的代码，他做了很好的error handle ,值得学习于应用。



### 具体实现可以参考我的代码，下面是我实现的功能展示。

1. 支持所有bash本来就有的命令的执行，比如ls、grep、echo、‘rm’等命令。
2. 支持**多个进程组成**的管道，如下图

![image-20211127134404462](https://gitee.com/wzjia/picturetwo/raw/master/img/202111271425181.png)

3. 支持‘&’，fg [%jid | pid]，bg， jobs一些作业控制命令，另外我并没有实现bg ，fg 这样的直接执行上一个job的命令，但也差不多了，有兴趣的伙伴可以试试。下面两张图是一些操作过程。

   ![image-20211127134658968](https://gitee.com/wzjia/picturetwo/raw/master/img/202111271425182.png)

![image-20211127134544634](https://gitee.com/wzjia/picturetwo/raw/master/img/202111271425183.png)

4. 实现了一些基本的重定向 ‘>’ , '<', '>>'，这个实际上没什么技术含量，哈哈，重定向一下就好啦。

   ![image-20211127135624116](https://gitee.com/wzjia/picturetwo/raw/master/img/202111271425184.png)

5. 这个tsh没有实现&&，|| 这样的命令，我觉得实现这些命令和管道是类似的，只不过不必重定向了

5. 这个shell也做了不少的error handle，不过肯定还是有没考虑到的，或者是不想写的，如果你有兴趣，可以试着完善一些

最后我提供了一个test.sh在test里可以配合csapp提供的sdriver.pl一起测试，但是我不知道他这个pl是什么机制，一直找不到myspin等等，他的makefile我也用不了.... 我不知道该把这些放到哪个目录下，所以最后我是人工测试了他的trace，基本上都符合我的预期，你也可以试试智能化（bash test.sh）哈哈，如果你能解决command not found 这应该会更棒！

### 总结

最后我觉得这个shell让我学到了很多信号、会话、进程组的概念，这些概念我以前也在书上看到过，但说实话根本没觉得多难，因为概念真的很简单，但是这个信号其实也涉及到多进程这样概念了，信号的处理和信号量的处理是有一些类似之处的，**这样我们在考虑的时候，就必须考虑信号原子性操作，稍有不慎就是极难调试的错误！！**还有就是前台进程组的概念：在一个会话中，某一时刻**只能有一个进程组能够从终端读入数据，其中只有一个进程能从终端读入数据**（这里可以看出，是可以多个后台进程组一起输出的）。