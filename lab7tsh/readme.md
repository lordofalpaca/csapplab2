我的实现用到了会话的概念，并实现了管道和重定向，是csapplab7的扩展版.

这是csapp的lab7，我是按照网上找的2002版的原型代码改动的，我也参考了一些博主的代码，不过大部分网上的代码实现版本是没有考虑管道的，以及真正的**会话的概念**，有的是是让父进程和子进程在一个前台进程组中，有的是没有使用tcsetpgrp来切换前台进程组，**那么他的shell的前台进程组就一直是父进程**，即便pause或者sigsuspend了。但是给子进程（命令）的信号就会被父进程劫走。这样是实现不了真正的管道和jobs管理的，因为概念都不对，是不能很好的扩展的，当然**这个实验并没有要求管道和重定向**，不过没有管道和重定向的shell实现起来总觉得缺点意思，如果想实现管道的话，建议不要参考那些代码。所以我对任务的实现是分出了多个进程组的，一个命令就是一个进程组就是一个job，维护一个前台进程组就行了。这个在附带的pdf后面是提到了的。

如果你去搜过GitHub你会发现很多myshell都很容易就死了，还有一些tsh因为他们的设计者没有明白前台进程组的概念，所以他们的tsh fork出的进程根本就不能读数据，这样的tsh虽然也可以通过lab的测试，但从本质上来说是不正确的。**因为例如一个 `/bin/bash -c read line` 这样的读入命令都执行不了，这个新进程会被直接暂停。**

ps：我的运行环境是：ubuntu:20.04，clang version 10.0.0-4ubuntu1 Target: x86_64-pc-linux-gnu，

### 概念

会话：由多个进程组、（可能拥有一个）控制终端构成。如果一个进程拥有一个控制终端，那么打开/dev/tty就能获得该终端的文件描述符。其中由一个首进程 pid == sid == pgid

进程组：由多个进程构成，其中有一个首进程pid == pgid

前台进程组：某特定时刻唯一一个可以从终端读入的进程组

作业job：一个命令：一个进程组

而shell一般就是一个会话的首进程，并且和一个控制终端相关联。

**最后我的实现也没有创建一个新会话，而是在原会话使用bash的终端，模拟了bash，另外我省略了一些会话相关的信号的处理，因为我并不是想真正做一个shell，而是想尽可能多的模仿出bash的核心功能，从中学习信号、会话、管道、父子进程、进程组等的概念与使用。**

### 下面是我的设计思路：

1. 父进程也就是tsh就是shell，按照'|' 管道分出**每一个命令，每一个命令是一个进程，父进程依次fork，并执行重定向等处理**
2. 分出的首进程就是，组pid， 然后一个命令中的所有进程都在一个进程组里
3. 父进程要捕捉，子进程的死亡、暂停、因为暂停和死亡的处理不同，所以引入job.processNumber和 fg_num ，依次表示一个job中还存在的进程，**和前台进程组中还在运行的进程数量**。

4. 另外，因为我这里是用信号来捕捉，（事实上我觉得这是最好的方法了）， **所以我只能捕捉到pid**，但是要pgid才能和一个job关联，所以父进程会进行一下group，（一个简单的类似hash的表），映射pid到pgid，方便singhandle处理。

5. 最后就是一些信号处理的细节，一定要保证addjob在deletejob之前！！所以要addjob之后才解开SIGCHLD的阻塞，还有fg_num也是如此。

   

### 下面是各个文件的作用：

1. tsh.c：是整个程序的前端部分，**加上整个程序的逻辑处理**，和管道处理，已经命令的创建和执行，还包括了addjob
2. jobs.c： 实现了jobs控制所需的代码
3. signalHandle.c： 信号处理的代码
4. sio.c ：cs_app 作者提供的信号安全的printf，实际上就是封装了的read
5. tools.c： 我自己实现的一系列字符串处理函数
6. get_num.c： 这是Michael Kerrisk（unix/linux系统编程手册原作者）提供的string_to——numberd的代码，他做了很好的error handle ,值得学习于应用。



### 具体实现可以参考我的代码，下面是我实现的功能展示。

1. 支持所有bash本来就有的命令的执行，比如ls、grep、echo、‘rm’等命令。
2. 支持**多个进程组成**的管道，如下图

![image-20211127134404462](https://gitee.com/wzjia/picturetwo/raw/master/img/202111271425181.png)

3. 支持‘&’，fg [%jid | pid]，bg， jobs一些作业控制命令，另外我并没有实现bg ，fg 这样的直接执行上一个job的命令，但也差不多了，有兴趣的伙伴可以试试。下面两张图是一些操作过程。

   ![image-20211127134658968](https://gitee.com/wzjia/picturetwo/raw/master/img/202111271425182.png)

![image-20211127134544634](https://gitee.com/wzjia/picturetwo/raw/master/img/202111271425183.png)

4. 实现了一些基本的重定向 ‘>’ , '<', '>>'，这个实际上没什么技术含量，哈哈，重定向一下就好啦。

   ![image-20211127135624116](https://gitee.com/wzjia/picturetwo/raw/master/img/202111271425184.png)

5. 这个tsh没有实现&&，|| 这样的命令，我觉得实现这些命令和管道是类似的，只不过不必重定向了

5. 这个shell也做了不少的error handle，不过肯定还是有没考虑到的，或者是不想写的，如果你有兴趣，可以试着完善一些

最后我提供了一个test.sh在test里可以配合csapp提供的sdriver.pl一起测试，**直接（bash test.sh）**，然后test里会生成result.txt，你可以检查一下这两个文件，观察一下是否符合你的预期，最好还是不要用diff来检查了，除了pid的不同以外，还要做和他一样的错误输出以及预期输出，这挺麻烦的。并且也有些脱离主线

![image-20211130234601069](https://gitee.com/wzjia/picturetwo/raw/master/img/202111302352250.png)

最后你可以通过对比一下生成的result.txt和tshref.out

![image-20211130234753226](https://gitee.com/wzjia/picturetwo/raw/master/img/202111302352260.png)

### 总结

最后我觉得这个shell让我学到了很多信号、会话、进程组的概念，这些概念我以前也在书上看到过，但说实话根本没觉得多难，因为概念真的很简单，但是这个信号其实也涉及到多进程这样概念了，信号的处理和信号量的处理是有一些类似之处的，**这样我们在考虑的时候，就必须考虑信号原子性操作，稍有不慎就是极难调试的错误！！**还有就是前台进程组的概念：在一个会话中，某一时刻**只能有一个进程组能够从终端读入数据，其中只有一个进程能从终端读入数据**（这里可以看出，是可以多个后台进程组一起输出的）。